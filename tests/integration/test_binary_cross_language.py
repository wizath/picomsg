"""
Binary cross-language compatibility tests for PicoMsg.

Tests that binary data generated by one language can be read by another,
ensuring true cross-language interoperability.
"""

import pytest
import tempfile
import subprocess
import sys
import struct
from pathlib import Path
from picomsg.schema.parser import SchemaParser
from picomsg.codegen.python import PythonCodeGenerator
from picomsg.codegen.c import CCodeGenerator
from picomsg.codegen.rust import RustCodeGenerator


class TestBinaryCrossLanguageEnums:
    """Test binary enum compatibility across languages."""
    
    def setup_method(self):
        """Set up test environment."""
        self.temp_dir = Path(tempfile.mkdtemp())
        self.schema_file = self.temp_dir / "test.pico"
        
    def teardown_method(self):
        """Clean up test environment."""
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_enum_binary_format_verification(self):
        """Test that enum binary format matches expected byte layout."""
        schema_text = """
        namespace test.binary;
        
        enum Priority : u8 {
            Low = 1,
            Medium = 5,
            High = 10,
        }
        
        enum Status : u16 {
            Inactive = 0,
            Active = 100,
            Pending = 200,
        }
        
        struct TaskInfo {
            id: u32;
            priority: Priority;
            status: Status;
            completed: bool;
        }
        """
        
        # Generate Python code
        self.schema_file.write_text(schema_text)
        parser = SchemaParser()
        schema = parser.parse_file(self.schema_file)
        
        generator = PythonCodeGenerator(schema)
        files = generator.generate()
        python_file = self.temp_dir / "picomsg_generated.py"
        python_file.write_text(files["picomsg_generated.py"])
        
        # Import and test
        sys.path.insert(0, str(self.temp_dir))
        
        # Clear module cache
        if 'picomsg_generated' in sys.modules:
            del sys.modules['picomsg_generated']
        
        import picomsg_generated
        
        # Create task with specific values
        task = picomsg_generated.TestBinaryTaskInfo(
            id=0x12345678,
            priority=picomsg_generated.TestBinaryPriority.High,
            status=picomsg_generated.TestBinaryStatus.Active,
            completed=True
        )
        
        data = task.to_bytes()
        
        # Verify binary format manually
        # Expected layout: id(u32) + priority(u8) + status(u16) + completed(bool)
        # Packed layout: id(4) + priority(1) + status(2) + completed(1) = 8 bytes
        expected_size = 4 + 1 + 2 + 1  # Packed without padding
        assert len(data) == expected_size
        
        # Verify the actual values in the binary data
        # id = 0x12345678 (little endian u32)
        assert data[0:4] == struct.pack('<I', 0x12345678)
        
        # priority = High = 10 (u8)
        assert data[4] == 10
        
        # status = Active = 100 (little endian u16) at bytes 5-6
        assert data[5:7] == struct.pack('<H', 100)
        
        # completed = True = 1 (bool) at byte 7
        assert data[7] == 1
        
        # Test deserialization
        task2 = picomsg_generated.TestBinaryTaskInfo.from_bytes(data)
        assert task2.id == 0x12345678
        assert task2.priority == picomsg_generated.TestBinaryPriority.High
        assert task2.status == picomsg_generated.TestBinaryStatus.Active
        assert task2.completed == True
    
    def test_enum_value_consistency(self):
        """Test that enum values are consistent across different schemas."""
        schema_text = """
        namespace test.consistency;
        
        enum Color : u8 {
            Red = 1,
            Green = 2,
            Blue = 3,
            Yellow = 10,
            Purple = 255,
        }
        
        struct Pixel {
            x: u16;
            y: u16;
            color: Color;
        }
        """
        
        # Generate Python code
        self.schema_file.write_text(schema_text)
        parser = SchemaParser()
        schema = parser.parse_file(self.schema_file)
        
        generator = PythonCodeGenerator(schema)
        files = generator.generate()
        python_file = self.temp_dir / "picomsg_generated.py"
        python_file.write_text(files["picomsg_generated.py"])
        
        # Import and test
        sys.path.insert(0, str(self.temp_dir))
        
        # Clear module cache
        if 'picomsg_generated' in sys.modules:
            del sys.modules['picomsg_generated']
        
        import picomsg_generated
        
        # Test all enum values
        assert picomsg_generated.TestConsistencyColor.Red.value == 1
        assert picomsg_generated.TestConsistencyColor.Green.value == 2
        assert picomsg_generated.TestConsistencyColor.Blue.value == 3
        assert picomsg_generated.TestConsistencyColor.Yellow.value == 10
        assert picomsg_generated.TestConsistencyColor.Purple.value == 255
        
        # Test binary representation of each color
        colors_and_values = [
            (picomsg_generated.TestConsistencyColor.Red, 1),
            (picomsg_generated.TestConsistencyColor.Green, 2),
            (picomsg_generated.TestConsistencyColor.Blue, 3),
            (picomsg_generated.TestConsistencyColor.Yellow, 10),
            (picomsg_generated.TestConsistencyColor.Purple, 255),
        ]
        
        for color_enum, expected_value in colors_and_values:
            pixel = picomsg_generated.TestConsistencyPixel(x=100, y=200, color=color_enum)
            data = pixel.to_bytes()
            
            # The color should be stored as a single byte with the expected value
            # Find the color byte in the data (after x=100, y=200)
            color_byte_found = False
            for i in range(len(data)):
                if data[i] == expected_value:
                    color_byte_found = True
                    break
            
            assert color_byte_found, f"Color value {expected_value} not found in binary data for {color_enum}"
            
            # Test deserialization
            pixel2 = picomsg_generated.TestConsistencyPixel.from_bytes(data)
            assert pixel2.color == color_enum


class TestBinaryCrossLanguageFixedArrays:
    """Test binary fixed array compatibility across languages."""
    
    def setup_method(self):
        """Set up test environment."""
        self.temp_dir = Path(tempfile.mkdtemp())
        self.schema_file = self.temp_dir / "test.pico"
        
    def teardown_method(self):
        """Clean up test environment."""
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_fixed_array_binary_layout(self):
        """Test that fixed arrays have the expected binary layout."""
        schema_text = """
        namespace test.arrays;
        
        struct Vector3 {
            coords: [f32:3];
        }
        
        struct Matrix2x2 {
            values: [f32:4];
        }
        
        struct ByteArray {
            data: [u8:8];
        }
        """
        
        # Generate Python code
        self.schema_file.write_text(schema_text)
        parser = SchemaParser()
        schema = parser.parse_file(self.schema_file)
        
        generator = PythonCodeGenerator(schema)
        files = generator.generate()
        python_file = self.temp_dir / "picomsg_generated.py"
        python_file.write_text(files["picomsg_generated.py"])
        
        # Import and test
        sys.path.insert(0, str(self.temp_dir))
        
        # Clear module cache
        if 'picomsg_generated' in sys.modules:
            del sys.modules['picomsg_generated']
        
        import picomsg_generated
        
        # Test Vector3 (3 f32 values)
        vec = picomsg_generated.TestArraysVector3(coords=[1.5, 2.5, 3.5])
        data = vec.to_bytes()
        
        # Should be exactly 3 * 4 = 12 bytes
        assert len(data) == 12
        
        # Verify each float value
        expected = struct.pack('<fff', 1.5, 2.5, 3.5)
        assert data == expected
        
        # Test Matrix2x2 (4 f32 values)
        matrix = picomsg_generated.TestArraysMatrix2x2(values=[1.0, 2.0, 3.0, 4.0])
        data = matrix.to_bytes()
        
        # Should be exactly 4 * 4 = 16 bytes
        assert len(data) == 16
        
        # Verify each float value
        expected = struct.pack('<ffff', 1.0, 2.0, 3.0, 4.0)
        assert data == expected
        
        # Test ByteArray (8 u8 values)
        byte_array = picomsg_generated.TestArraysByteArray(data=[1, 2, 3, 4, 5, 6, 7, 8])
        data = byte_array.to_bytes()
        
        # Should be exactly 8 bytes
        assert len(data) == 8
        
        # Verify each byte value
        expected = bytes([1, 2, 3, 4, 5, 6, 7, 8])
        assert data == expected
    
    def test_fixed_array_with_enums(self):
        """Test fixed arrays containing enums."""
        schema_text = """
        namespace test.enumarrays;
        
        enum Direction : u8 {
            North = 0,
            East = 1,
            South = 2,
            West = 3,
        }
        
        struct Path {
            directions: [Direction:4];
        }
        """
        
        # Generate Python code
        self.schema_file.write_text(schema_text)
        parser = SchemaParser()
        schema = parser.parse_file(self.schema_file)
        
        generator = PythonCodeGenerator(schema)
        files = generator.generate()
        python_file = self.temp_dir / "picomsg_generated.py"
        python_file.write_text(files["picomsg_generated.py"])
        
        # Import and test
        sys.path.insert(0, str(self.temp_dir))
        
        # Clear module cache
        if 'picomsg_generated' in sys.modules:
            del sys.modules['picomsg_generated']
        
        import picomsg_generated
        
        # Create path with specific directions
        path = picomsg_generated.TestEnumarraysPath(directions=[
            picomsg_generated.TestEnumarraysDirection.North,
            picomsg_generated.TestEnumarraysDirection.East,
            picomsg_generated.TestEnumarraysDirection.South,
            picomsg_generated.TestEnumarraysDirection.West,
        ])
        
        data = path.to_bytes()
        
        # Should be exactly 4 bytes (4 u8 enum values)
        assert len(data) == 4
        
        # Verify each enum value
        expected = bytes([0, 1, 2, 3])  # North, East, South, West
        assert data == expected
        
        # Test deserialization
        path2 = picomsg_generated.TestEnumarraysPath.from_bytes(data)
        assert len(path2.directions) == 4
        assert path2.directions[0] == picomsg_generated.TestEnumarraysDirection.North
        assert path2.directions[1] == picomsg_generated.TestEnumarraysDirection.East
        assert path2.directions[2] == picomsg_generated.TestEnumarraysDirection.South
        assert path2.directions[3] == picomsg_generated.TestEnumarraysDirection.West


class TestBinaryCrossLanguageComplex:
    """Test complex binary structures across languages."""
    
    def setup_method(self):
        """Set up test environment."""
        self.temp_dir = Path(tempfile.mkdtemp())
        self.schema_file = self.temp_dir / "test.pico"
        
    def teardown_method(self):
        """Clean up test environment."""
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_complex_nested_structure(self):
        """Test complex nested structures with enums and fixed arrays."""
        schema_text = """
        namespace test.complex;
        
        enum Priority : u8 {
            Low = 1,
            Medium = 5,
            High = 10,
        }
        
        struct Point {
            x: f32;
            y: f32;
        }
        
        struct GameEntity {
            id: u32;
            position: Point;
            priority: Priority;
            health: u8;
            inventory: [u16:3];
            active: bool;
        }
        """
        
        # Generate Python code
        self.schema_file.write_text(schema_text)
        parser = SchemaParser()
        schema = parser.parse_file(self.schema_file)
        
        generator = PythonCodeGenerator(schema)
        files = generator.generate()
        python_file = self.temp_dir / "picomsg_generated.py"
        python_file.write_text(files["picomsg_generated.py"])
        
        # Import and test
        sys.path.insert(0, str(self.temp_dir))
        
        # Clear module cache
        if 'picomsg_generated' in sys.modules:
            del sys.modules['picomsg_generated']
        
        import picomsg_generated
        
        # Create complex entity
        entity = picomsg_generated.TestComplexGameEntity(
            id=0xDEADBEEF,
            position=picomsg_generated.TestComplexPoint(x=123.45, y=678.90),
            priority=picomsg_generated.TestComplexPriority.High,
            health=85,
            inventory=[1001, 2002, 3003],
            active=True
        )
        
        # Serialize and verify
        data = entity.to_bytes()
        
        # Test deserialization
        entity2 = picomsg_generated.TestComplexGameEntity.from_bytes(data)
        
        # Verify all fields
        assert entity2.id == 0xDEADBEEF
        assert abs(entity2.position.x - 123.45) < 0.001  # Float precision
        assert abs(entity2.position.y - 678.90) < 0.001
        assert entity2.priority == picomsg_generated.TestComplexPriority.High
        assert entity2.health == 85
        assert entity2.inventory == [1001, 2002, 3003]
        assert entity2.active == True
        
        # Test JSON roundtrip
        json_str = entity.to_json()
        entity3 = picomsg_generated.TestComplexGameEntity.from_json(json_str)
        
        assert entity3.id == entity.id
        assert entity3.priority == entity.priority
        assert entity3.health == entity.health
        assert entity3.inventory == entity.inventory
        assert entity3.active == entity.active
    
    def test_binary_format_stability(self):
        """Test that binary format is stable across multiple serializations."""
        schema_text = """
        namespace test.stability;
        
        enum Status : u16 {
            Ready = 100,
            Processing = 200,
            Complete = 300,
        }
        
        struct Record {
            timestamp: u64;
            status: Status;
            flags: [bool:4];
            data: [u8:8];
        }
        """
        
        # Generate Python code
        self.schema_file.write_text(schema_text)
        parser = SchemaParser()
        schema = parser.parse_file(self.schema_file)
        
        generator = PythonCodeGenerator(schema)
        files = generator.generate()
        python_file = self.temp_dir / "picomsg_generated.py"
        python_file.write_text(files["picomsg_generated.py"])
        
        # Import and test
        sys.path.insert(0, str(self.temp_dir))
        
        # Clear module cache
        if 'picomsg_generated' in sys.modules:
            del sys.modules['picomsg_generated']
        
        import picomsg_generated
        
        # Create record with specific values
        record = picomsg_generated.TestStabilityRecord(
            timestamp=1640995200000,
            status=picomsg_generated.TestStabilityStatus.Processing,
            flags=[True, False, True, False],
            data=[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
        )
        
        # Serialize multiple times and verify consistency
        data1 = record.to_bytes()
        data2 = record.to_bytes()
        data3 = record.to_bytes()
        
        assert data1 == data2 == data3
        
        # Deserialize and re-serialize
        record2 = picomsg_generated.TestStabilityRecord.from_bytes(data1)
        data4 = record2.to_bytes()
        
        assert data1 == data4
        
        # Verify all values are preserved
        assert record2.timestamp == 1640995200000
        assert record2.status == picomsg_generated.TestStabilityStatus.Processing
        assert record2.flags == [True, False, True, False]
        assert record2.data == [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08] 
