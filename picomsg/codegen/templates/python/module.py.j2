"""Generated PicoMsg Python bindings"""
# This file is auto-generated. Do not edit manually.

import struct
import json
import base64
from enum import IntEnum
from typing import Dict, Any, Optional, Union, List
from io import BytesIO

# PicoMsg format constants
{{ namespace_prefix | upper if namespace_prefix else 'PICOMSG' }}_MAGIC_BYTE_1 = 0xAB
{{ namespace_prefix | upper if namespace_prefix else 'PICOMSG' }}_MAGIC_BYTE_2 = 0xCD
{{ namespace_prefix | upper if namespace_prefix else 'PICOMSG' }}_VERSION = {{ schema.version if schema.version else 1 }}
{{ namespace_prefix | upper if namespace_prefix else 'PICOMSG' }}_HEADER_SIZE = 8

# Message type IDs
{% for message in schema.messages %}
{{ namespace_prefix | upper if namespace_prefix else 'PICOMSG' }}_{{ message.name | upper }}_TYPE_ID = {{ loop.index }}
{% endfor %}

# Error classes
class {{ namespace_prefix if namespace_prefix else 'PicoMsg' }}Error(Exception):
    """Base exception for PicoMsg errors."""
    pass

class {{ namespace_prefix if namespace_prefix else 'PicoMsg' }}ErrorInvalidHeader({{ namespace_prefix if namespace_prefix else 'PicoMsg' }}Error):
    """Invalid header error."""
    pass

class {{ namespace_prefix if namespace_prefix else 'PicoMsg' }}ErrorBufferTooSmall({{ namespace_prefix if namespace_prefix else 'PicoMsg' }}Error):
    """Buffer too small error."""
    pass

class {{ namespace_prefix if namespace_prefix else 'PicoMsg' }}ErrorInvalidData({{ namespace_prefix if namespace_prefix else 'PicoMsg' }}Error):
    """Invalid data error."""
    pass

class {{ namespace_prefix if namespace_prefix else 'PicoMsg' }}Base:
    """Base class for all PicoMsg types."""
    
    def __init__(self):
        pass
    
    @classmethod
    def from_bytes(cls, data: bytes) -> "Self":
        """Create instance from binary data."""
        instance = cls()
        instance._deserialize_from_bytes(data)
        return instance
    
    def to_bytes(self) -> bytes:
        """Convert to binary data."""
        return self._serialize_to_bytes()
    
    def _serialize_to_bytes(self) -> bytes:
        """Serialize instance to bytes with proper variable-length handling."""
        buffer = BytesIO()
        self._write_to_buffer(buffer)
        return buffer.getvalue()
    
    def _deserialize_from_bytes(self, data: bytes) -> None:
        """Deserialize instance from bytes with proper variable-length handling."""
        buffer = BytesIO(data)
        self._read_from_buffer(buffer)
    
    def _write_to_buffer(self, buffer: BytesIO) -> None:
        """Write instance to buffer. Must be implemented by subclasses."""
        raise NotImplementedError("Subclasses must implement _write_to_buffer")
    
    def _read_from_buffer(self, buffer: BytesIO) -> None:
        """Read instance from buffer. Must be implemented by subclasses."""
        raise NotImplementedError("Subclasses must implement _read_from_buffer")
    
    @classmethod
    def from_buffer(cls, buffer: BytesIO) -> "Self":
        """Create instance from buffer."""
        instance = cls()
        instance._read_from_buffer(buffer)
        return instance
    
    def to_buffer(self, buffer: BytesIO) -> None:
        """Write to buffer."""
        self._write_to_buffer(buffer)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        raise NotImplementedError("Subclasses must implement to_dict")
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Self":
        """Create instance from dictionary."""
        raise NotImplementedError("Subclasses must implement from_dict")
    
    def to_json(self, indent: Optional[int] = None) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=indent)
    
    @classmethod
    def from_json(cls, json_str: str) -> "Self":
        """Create instance from JSON string."""
        data = json.loads(json_str)
        return cls.from_dict(data)
    
    def to_base64(self) -> str:
        """Convert to base64 encoded string."""
        return base64.b64encode(self.to_bytes()).decode("ascii")
    
    @classmethod
    def from_base64(cls, base64_str: str) -> "Self":
        """Create instance from base64 encoded string."""
        data = base64.b64decode(base64_str.encode("ascii"))
        return cls.from_bytes(data)

{% for enum in schema.enums %}
{% include 'python/enum.py.j2' %}

{% endfor %}
{% for struct in schema.structs %}
{% include 'python/struct.py.j2' %}

{% endfor %}
{% for message in schema.messages %}
{% include 'python/message.py.j2' %}

{% endfor %} 